#!/usr/bin/env python
# coding: utf-8
"""Eve configuration file for buildbot.

This module is the core source code of eve.
It is in fact the configuration file for buildbot.
See the `Buildbot Manual`_ for more informations.

.. _Buildbot Manual:
    http://docs.buildbot.net/latest/manual/index.html
"""

import json
import re
import shutil
import subprocess
from collections import OrderedDict
from fnmatch import fnmatch
from os import environ, path
from random import randint

import docker
import yaml
from buildbot.changes.gitpoller import GitPoller
from buildbot.config import BuilderConfig
from buildbot.plugins import steps
from buildbot.process import buildrequest, logobserver
from buildbot.process.buildstep import BuildStep
from buildbot.process.factory import BuildFactory
from buildbot.process.properties import Interpolate, Property
from buildbot.process.results import (CANCELLED, EXCEPTION, FAILURE, RETRY,
                                      SKIPPED, SUCCESS, WARNINGS, Results)
from buildbot.reporters.http import HttpStatusPushBase
from buildbot.scheduler import AnyBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.schedulers.triggerable import Triggerable
from buildbot.schedulers.trysched import Try_Userpass
from buildbot.steps.http import HTTPStep
from buildbot.steps.master import SetProperty
from buildbot.steps.shell import SetPropertyFromCommand, ShellCommand
from buildbot.steps.source.git import Git
from buildbot.steps.trigger import Trigger
from buildbot.worker.docker import DockerLatentWorker
from buildbot.worker.local import LocalWorker
from buildbot.worker.openstack import OpenStackLatentWorker
from buildbot.www.authz import Authz, endpointmatchers, roles
from buildbot.www.oauth2 import GoogleAuth
from raven import Client
from raven.transport.twisted import TwistedHTTPTransport
from requests.auth import HTTPBasicAuth
from twisted.internet import threads
from twisted.internet.defer import inlineCallbacks, returnValue, succeed
from twisted.logger import ILogObserver, Logger, globalLogPublisher
from twisted.python.reflect import namedModule
from zope.interface import provider

##########################
# Constants
##########################
BOOTSTRAP_BUILDER_NAME = 'bootstrap'
BOOTSTRAP_SCHEDULER_NAME = 'bootstrap-sched'
DOCKER_BUILDER_NAME = 'docker-build'
DOCKER_SCHEDULER_NAME = 'docker-scheduler'
OPENSTACK_BUILDER_NAME = 'openstack-build'
OPENSTACK_SCHEDULER_NAME = 'openstack-scheduler'
MAX_LOCAL_WORKERS = 10
MAX_DOCKER_WORKERS = 20
MAX_OPENSTACK_WORKERS = 20
EVE_FOLDER = 'eve'
EVE_MAIN_YAML = 'main.yml'
EVE_MAIN_YAML_FULL_PATH = '%s/%s' % (EVE_FOLDER, EVE_MAIN_YAML)

OPENSTACK_IDENTITY_URL = 'https://identity.api.rackspacecloud.com/v2.0/'
OPENSTACK_REGION = 'DFW'
OPENSTACK_TENANT = 984990

##########################
# Set/Check environment variables
##########################
# git
GIT_REPO = environ.pop('GIT_REPO')
GIT_REPO_SHORT = GIT_REPO.split('/')[-1].replace('.git', '')
GIT_CACHE_DIR_HOST = '/tmp/' + GIT_REPO_SHORT
GIT_CACHE_DIR_CONTAINER = '/home/eve/cache/git'
if not GIT_REPO.startswith('git://'):
    # git protocol is anonymous
    GIT_KEY_PATH = environ.pop('GIT_KEY_PATH')
    assert path.isfile(GIT_KEY_PATH), (
        'Did not find git RSA cert in %s' % GIT_KEY_PATH)
    assert path.isfile(GIT_KEY_PATH + '.pub'), (
        'Did not find public git RSA cert in %s' % GIT_KEY_PATH)
# Sentry
SENTRY_DSN = environ.pop('SENTRY_DSN', None)

# docker

EXTERNAL_URL = environ.pop('EXTERNAL_URL')
MASTER_FQDN = environ.pop('MASTER_FQDN')
DOCKER_PREFIX = environ.pop('DOCKER_PREFIX')

DOCKER_HOST = environ.pop('DOCKER_HOST', 'unix:///var/run/docker.sock')
DOCKER_CERT_PATH = environ.pop('DOCKER_CERT_PATH', None)
if DOCKER_CERT_PATH and path.isdir(DOCKER_CERT_PATH):
    DOCKER_CERT_PATH_CA = path.join(DOCKER_CERT_PATH, 'ca.pem')
    DOCKER_CERT_PATH_KEY = path.join(DOCKER_CERT_PATH, 'key.pem')
    DOCKER_CERT_PATH_CERT = path.join(DOCKER_CERT_PATH, 'cert.pem')
    assert path.isfile(DOCKER_CERT_PATH_CA), DOCKER_CERT_PATH_CA
    assert path.isfile(DOCKER_CERT_PATH_KEY), DOCKER_CERT_PATH_KEY
    assert path.isfile(DOCKER_CERT_PATH_CERT), DOCKER_CERT_PATH_CERT
    TLS_CONFIG = docker.tls.TLSConfig(
        client_cert=(
            DOCKER_CERT_PATH_CERT,
            DOCKER_CERT_PATH_KEY),
        ca_cert=DOCKER_CERT_PATH_CA,
        verify=False)
else:
    TLS_CONFIG = None

# bitbucket
EVE_BITBUCKET_LOGIN = environ.pop('EVE_BITBUCKET_LOGIN')
EVE_BITBUCKET_PWD = environ.pop('EVE_BITBUCKET_PWD')

OAUTH2_CLIENT_ID = environ.pop('OAUTH2_CLIENT_ID')
OAUTH2_CLIENT_SECRET = environ.pop('OAUTH2_CLIENT_SECRET')

PROJECT_NAME = environ.pop('PROJECT_NAME')
PROJECT_URL = environ.pop('PROJECT_URL')

TRY_PWD = environ.pop('TRY_PWD')

# database
DB_URL = environ.pop('DB_URL', 'sqlite:///state.sqlite')

RAX_LOGIN = environ.pop('RAX_LOGIN', None)
RAX_PWD = environ.pop('RAX_PWD', None)

# artifacts

DEFAULT_CLOUDFILES_URL = 'https://storage101.dfw1.clouddrive.com/' \
                         'v1/MossoCloudFS_984990/'
CLOUDFILES_URL = environ.pop('CLOUDFILES_URL', DEFAULT_CLOUDFILES_URL)
ARTIFACTS_PREFIX = environ.pop('ARTIFACTS_PREFIX', 'staging-')


##########################
# Project Identity
##########################
EVE_CONF = BuildmasterConfig = OrderedDict()  # pylint: disable=invalid-name
EVE_CONF['title'] = "the %s project" % PROJECT_NAME
EVE_CONF['titleURL'] = PROJECT_URL
EVE_CONF['buildbotURL'] = EXTERNAL_URL

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that
# workers could connect to your master with this protocol.
# 'port' must match the value configured into the buildworkers (with their
# --master option)
EVE_CONF['protocols'] = {'pb': {'port': environ['PB_PORT']}}

##########################
# HipChat Configuration
##########################
REPO_ICON = 'http://www.packal.org/sites/default/files/public/styles/icon_' \
            'large/public/workflow-files/netdeanishealfred-git-repos/icon/' \
            'icon.png?itok=1zkuMgPa'
BRANCH_ICON = 'http://plainicon.com/dboard/userprod/2800_a1826/prod_thumb/' \
              'plainicon.com-50219-512px-201.png'
CLOCK_ICON = 'https://image.freepik.com/free-icon/clock-of-circular-shape-at' \
             '-two-o-clock_318-48022.jpg'

HIPCHAT_TOKEN = environ.pop('HIPCHAT_TOKEN')
HIPCHAT_ROOM = environ.pop('HIPCHAT_ROOM')

##########################
# Web UI
##########################
# Create a basic auth website with the waterfall view and the console view

EVE_CONF['www'] = dict(
    port=environ['HTTP_PORT'],
    plugins=dict(waterfall_view={}, console_view={}),
    auth=GoogleAuth(OAUTH2_CLIENT_ID,
                    OAUTH2_CLIENT_SECRET),
    change_hook_dialects={'bitbucket': True},
)

# Limit write operations to the OAUTH2_CLIENT_ID account except for tests


class DeveloperRoleIfConnected(roles.RolesFromBase):
    """ Sets the 'developer' role to all authenticated users"""

    def getRolesFromUser(self, userDetails):
        if 'email' in userDetails:  # and userDetails['email']:
            return ['developer']
        return []

if OAUTH2_CLIENT_ID != 'test':
    EVE_CONF['www']['authz'] = Authz(
        allowRules=[
            endpointmatchers.AnyEndpointMatcher(role='developer'),
        ],
        roleMatchers=[
            DeveloperRoleIfConnected()
        ]
    )

# DB URL
EVE_CONF['db'] = {
    'db_url': DB_URL,
}


# #########################
# Reporters
# #########################
# Reporters send the build status when finished

class BaseBuildStatusPush(HttpStatusPushBase):
    """
    Base class for pushing build status
    """
    neededDetails = dict(wantProperties=True, wantSteps=True)
    RESULT_COLOR_CORRESP = {
        SUCCESS: 'green',
        WARNINGS: 'orange',
        FAILURE: 'red',
        SKIPPED: 'white',
        EXCEPTION: 'purple',
        RETRY: 'purple',
        CANCELLED: 'pink'}

    def gather_data(self, build):
        """
        Gathers data to be used in build status
        :param build: The build dictionary
        :return: (key, result, title, summary, description)
        """

        # from pprint import pformat
        # self.logger.debug('Sending build status to Reporter: {buildstatus}',
        #                    buildstatus=pformat(build, indent=2))

        key = 'pre-merge'  # fixme: this should be set dynamically
        src = build['buildset']['sourcestamps'][0]
        repo = GIT_REPO_SHORT
        branch = src['branch']
        title = 'build #%s' % build['buildid']
        summary = '(%s) build #%s on %s:%s ' % (
            build['state_string'], build['buildid'], repo, branch)

        self.add_tag('branch', branch, BRANCH_ICON, color='blue')
        self.add_tag('repository', repo, REPO_ICON, color='blue')

        result = build['results']
        description = 'in progress...'
        if result is not None:
            description = 'Hooray!'
            duration = (build['complete_at'] - build['started_at']).\
                total_seconds()
            summary += '[%s]' % Results[result]
            if result != SUCCESS:
                description = Results[result] + ' in step(s) : ' + ', '.join([
                    l['name'] for l in build['steps']
                    if l['results'] == build['results']])

            self.add_tag('result', Results[result], None,
                         color=self.RESULT_COLOR_CORRESP[result])
            self.add_tag('duration', '%d seconds' % duration, CLOCK_ICON,
                         color='gray')
        # fixme: add authors
        # authors = build.getResponsibleUsers()
        return key, result, title, summary, description

    def add_tag(self, name, value, icon, color=None):
        """
        Add a tag (name+value) to the status
        :param name: The name of the tag
        :param value: The value of the tag
        :param icon: a square image url (can be None) (HipChat Only)
        :param color: The color of the tag (HipChat Only)
        :return: None
        """
        raise NotImplementedError()


class HipChatBuildStatusPush(BaseBuildStatusPush):
    """Send build result to HipChat build status API."""
    name = "HipChatBuildStatusPush"
    logger = Logger('eve.steps.HipChatBuildStatusPush')
    attributes = []
    COLOR_STYLE_CORRESP = {
        'green': 'lozenge-success',
        'orange': 'lozenge-current',
        'red': 'lozenge-error',
        'white': 'lozenge',
        'purple': 'lozenge-error',
        'pink': 'lozenge-error',
        'brown': 'lozenge-moved',
        'blue': 'lozenge-complete',
        'gray': 'lozenge'}
    HIPCHAT_COLOR_CORRESP = {
        SUCCESS: 'green',
        WARNINGS: 'yellow',
        FAILURE: 'red',
        SKIPPED: 'gray',
        EXCEPTION: 'purple',
        RETRY: 'purple',
        CANCELLED: 'gray',
        None: 'gray'}

    def add_tag(self, name, value, icon, color=None):
        attr = dict(label=name, value=dict(label=value))
        if color in self.COLOR_STYLE_CORRESP:
            attr['value']['style'] = self.COLOR_STYLE_CORRESP[color]
        if icon:
            attr['value']['icon'] = dict(url=icon)
        self.attributes.append(attr)

    @inlineCallbacks
    def send(self, build):
        """Send build status to HipChat."""

        self.attributes = []
        key, result, title, summary, description = self.gather_data(build)

        headers = {
            'content-type': 'application/json',
            'authorization': 'Bearer %s' % HIPCHAT_TOKEN}

        card = dict(
            style='application',
            url=build['url'],
            format='medium',
            id=key,
            title=title,
            description=dict(format='text', value=description),
            attributes=self.attributes,
            activity=dict(html=summary))

        data = dict(
            message=summary,
            name=key,
            message_format='text',
            notify=True,
            card=card,
            color=self.HIPCHAT_COLOR_CORRESP[result])

        url = 'https://api.hipchat.com/v2/room/%s/notification' % HIPCHAT_ROOM

        if EVE_BITBUCKET_LOGIN == 'test':
            return  # Don't really push status for tests
        response = yield self.session.post(url, headers=headers, json=data)
        if response.status_code != 204:
            raise Exception(
                "{response.status_code}: unable to send status to HipChat: "
                "{url}\n{response.content}".format(response=response, url=url))
        self.logger.info("HipChat status sent")

# The status push works only on the main builder (bootstrap)
EVE_CONF['services'] = [HipChatBuildStatusPush(builders=['bootstrap'])]


class BitbucketBuildStatusPush(BaseBuildStatusPush):
    """Send build result to bitbucket build status API."""
    name = "BitbucketBuildStatusPush"
    description_suffix = ''
    logger = Logger('eve.steps.BitbucketBuildStatusPush')
    BITBUCKET_STATUS_CORRESP = {
        SUCCESS: 'SUCCESSFUL',
        WARNINGS: 'SUCCESSFUL',
        FAILURE: 'FAILED',
        SKIPPED: 'FAILED',
        EXCEPTION: 'FAILED',
        RETRY: 'FAILED',
        CANCELLED: 'FAILED',
        None: 'INPROGRESS'}

    @staticmethod
    def forge_url(build):
        """Forge the BB API URL on which the build status will be posted."""
        sha1 = build['buildset']['sourcestamps'][0]['revision']
        return 'https://api.bitbucket.org/2.0/repositories/' \
               '%(repo_owner)s/%(repo_name)s/commit/%(sha1)s/statuses/build' \
               % {
                   'repo_owner': 'scality',
                   'repo_name': GIT_REPO_SHORT,
                   'sha1': sha1
               }

    def add_tag(self, name, value, icon, color=None):
        name_value = '[%s: %s]' % (name, value)
        self.description_suffix = name_value + self.description_suffix

    @inlineCallbacks
    def send(self, build):
        """Send build status to Bitbucket."""
        self.description_suffix = ''
        key, result, _, summary, description = self.gather_data(build)
        data = {
            'state': self.BITBUCKET_STATUS_CORRESP[result],
            'key': key,
            "name": summary,
            "url": build['url'],
            "description": description + self.description_suffix
        }
        auth = HTTPBasicAuth(EVE_BITBUCKET_LOGIN, EVE_BITBUCKET_PWD)
        if EVE_BITBUCKET_LOGIN == 'test':
            return  # Don't really push status for tests
        url = self.forge_url(build)
        response = yield self.session.post(
            url, data, auth=auth)
        if response.status_code != 201:
            raise Exception(
                "{response.status_code}: unable to send status to Bitbucket: "
                "{url}\n{response.content}".format(response=response, url=url))
        self.logger.info("Bibucket status sent")

# The status push works only on the main builder (bootstrap)
EVE_CONF['services'].append(BitbucketBuildStatusPush(builders=['bootstrap']))

##########################
# ArtifactUpload
##########################

CURL_CMD = """ curl -s -X POST -H "Content-type: application/json" \
--progress-bar https://identity.api.rackspacecloud.com/v2.0/tokens \
-d "{\\"auth\\":{\\"passwordCredentials\\":{\\"username\\":\\"$RAX_LOGIN\\",\\"password\\":\\"$RAX_PWD\\"}}}"
"""


class CloudfilesAuthenticate(SetPropertyFromCommand):
    """ Authenticate with rackspace and store the auth token on a property."""

    def __init__(self, **kwargs):
        SetPropertyFromCommand.__init__(
            self,
            name='get cloudfiles authentication params',
            command=CURL_CMD,
            property='cloudfiles_token',
            haltOnFailure=True,
            env={'RAX_LOGIN': RAX_LOGIN, 'RAX_PWD': RAX_PWD},
            logEnviron=False,  # Obfuscate $RAX_PWD
            **kwargs
        )

    def commandComplete(self, cmd):  # NOQA flake8 to ignore camelCase
        if cmd.didFail():
            return
        output = json.loads(self.observer.getStdout())
        token = output["access"]["token"]["id"]
        self.setProperty(self.property, token, "CloudfilesAuthenticate")
        self.property_changes[self.property] = token


class Upload(ShellCommand):
    """ Upload files to rackspace
    """

    def __init__(self, source, **kwargs):
        ShellCommand.__init__(
            self,
            name='send artifacts to artifact respository',
            haltOnFailure=True,
            command=Interpolate(
                'cd ' + source +
                ' && tar -chvzf ../artifacts.tar.gz . '
                ' && curl -s '
                '-T ../artifacts.tar.gz '
                '-X PUT -H"x-auth-token: %(prop:cloudfiles_token)s" ' +
                CLOUDFILES_URL + ARTIFACTS_PREFIX +
                '%(prop:build_id)s?extract-archive=tar.gz'),
            **kwargs
        )
        self.observer = logobserver.BufferLogObserver(wantStdout=True,
                                                      wantStderr=True)
        self.addLogObserver('stdio', self.observer)

    def commandComplete(self, cmd):
        if cmd.didFail():
            return
        assert 'Response Status: 201 Created' in self.observer.getStdout()

##########################
# Workers
##########################
EVE_CONF['workers'] = []

# Create MAX_LOCAL_WORKERS Local Workers that will bootstrap all the jobs
LOCAL_WORKERS = []
for i in range(MAX_LOCAL_WORKERS):
    LOCAL_WORKERS.append(LocalWorker('lw%03d' % i))
EVE_CONF['workers'].extend(LOCAL_WORKERS)

# Then create MAX_DOCKER_WORKERS Docker Workers that will do the real job
DOCKER_WORKERS = []
for i in range(MAX_DOCKER_WORKERS):
    DOCKER_WORKERS.append(
        DockerLatentWorker(
            name='dw%03d-%s' % (i, DOCKER_PREFIX),
            password='pwd%d' % i,  # fixme: stronger passwords
            docker_host=DOCKER_HOST,
            hostconfig={},
            volumes=Property('docker_volumes'),
            tls=TLS_CONFIG,
            image=Property('docker_image'),
            followStartupLogs=True,
            masterFQDN=MASTER_FQDN))
EVE_CONF['workers'].extend(DOCKER_WORKERS)


class EveOpenStackLatentWorker(OpenStackLatentWorker):
    """Improved version of OpenStackLatentWorker that adds:
    - Support for regions (Required for Rackspace)
    - Automatically installs a buildbot slave after spawn using ssh
    """
    def __init__(self, **kwargs):
        OpenStackLatentWorker.__init__(self, **kwargs)
        # fixme: This is a fragile hack because the original class does not
        # allow to specify a region name. We should fix this upstream.
        self.novaclient.client.region_name = 'DFW'
        self.ip_address = None

    def ssh(self, cmd):
        """ Execute an ssh command on the instance.
        :param cmd: The command to launch
        :return: the output of the command
        """
        print cmd
        res = subprocess.check_output(
            'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no '
            '-o SendEnv=LC_ALL '
            'root@%s %s' % (self.ip_address, cmd), shell=True)
        print res
        return res

    def _start_instance(self):
        result = OpenStackLatentWorker._start_instance(self)
        if not self.instance:
            return result

        inst = self.novaclient.servers.get(self.instance.id)
        for network in inst.networks[u'public']:
            if re.match(r'\d+\.\d+\.\d+\.\d+', network):
                self.ip_address = network
                break
        else:
            #self.failed_to_start(instance.id, inst.status)
            assert False, 'Could not extract IP address'

        for _ in range(20):
            try:
                print 'MASTER_FQDN'
                print MASTER_FQDN
                self.ssh('apt-get update')
                self.ssh('apt-get install -y python-dev python-pip wget git')
                self.ssh('pip install buildbot-worker==0.9.0b9')
                self.ssh('buildbot-worker create-worker . "%s:%s" "%s" "%s"' %
                         (MASTER_FQDN, environ['PB_PORT'], self.name, self.password))
                self.ssh('buildbot-worker start')
            except subprocess.CalledProcessError as exception:
                print 'problem', exception, exception.output
                continue
            break
        return result

def get_image_by_name(images):
    for image in images:
        print image.name
        if image.name == 'Ubuntu 14.04 LTS (Trusty Tahr) (PVHVM)':
            return image

    raise Exception('Die Hard!')


# Then create MAX_OPENSTACK_WORKERS Docker Workers that will do the real job
OPENSTACK_WORKERS = []
for i in range(MAX_OPENSTACK_WORKERS):
    OPENSTACK_WORKERS.append(
        EveOpenStackLatentWorker(
            name='ow%03d-%s' % (i, DOCKER_PREFIX),
            password='pwd%d' % i,  # fixme: stronger passwords
            image=get_image_by_name,
            # flavor=Property('openstack_flavor'),
            flavor='general1-8',
            block_devices=None,
            os_auth_url=OPENSTACK_IDENTITY_URL,
            os_tenant_name=OPENSTACK_TENANT,
            os_username=RAX_LOGIN,
            os_password=RAX_PWD,
            meta=None,
            nova_args=dict(key_name='eve_ssh_keypair'),
            client_version='2'))
EVE_CONF['workers'].extend(OPENSTACK_WORKERS)

##########################
# Change Sources
##########################
# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

EVE_CONF['change_source'] = []
EVE_CONF['change_source'].append(GitPoller(
    GIT_REPO,
    workdir='gitpoller-workdir',
    branches=True,
    pollinterval=900,
    pollAtLaunch=False,
    buildPushesWithNoCommits=True,
))


##########################
# Custom Build Steps
##########################
class ReadConfFromYaml(SetPropertyFromCommand):
    """Load the YAML file to `conf` property.

    This step Reads the YAML file and converts it to a `conf` property which
    is made available to the following steps.
    """
    logger = Logger('eve.steps.ReadConfFromYaml')

    def __init__(self, **kwargs):
        SetPropertyFromCommand.__init__(
            self,
            name='read config from %s' % EVE_MAIN_YAML_FULL_PATH,
            command='cat %s' % EVE_MAIN_YAML_FULL_PATH,
            property='conf',
            haltOnFailure=True,
            **kwargs)

    def commandComplete(self, cmd):  # NOQA flake8 to ignore camelCase
        if cmd.didFail():
            return
        conf = yaml.load(self.observer.getStdout())
        # Expand entries with several branch patterns
        new_branches = {}
        for branch_patterns, branch_conf in conf['branches'].items():
            for branch_pattern in branch_patterns.split(','):
                new_branches[branch_pattern.strip()] = branch_conf
        conf['branches'] = new_branches
        self.setProperty(self.property, conf, "ReadConfFromYaml Step")
        self.property_changes[self.property] = conf
        # Find the stage name from the branch name
        branch = self.getProperty('branch', 'default')
        for branch_pattern, branch_conf in conf['branches'].items():
            self.logger.debug('Checking if <{branch}> matches <{pattern}>',
                              branch=branch, pattern=branch_pattern)
            if fnmatch(branch, branch_pattern):
                stage_name = branch_conf['stage']
                self.logger.debug('<{branch}> matched <{branch_pattern}>',
                                  branch=branch, branch_pattern=branch_pattern)
                break
        else:
            self.logger.debug('No branch match. Using default branch config.')
            try:
                stage_name = conf['branches']['default']['stage']
            except KeyError:
                self.logger.debug('No default. Stopping here.')
                return
        self.setProperty('stage_name', stage_name, 'ReadConfFromYaml Step')
        self.property_changes['stage_name'] = stage_name
        self.build.addStepsAfterCurrentStep([
            TriggerStages([stage_name], haltOnFailure=True)])


class StepExtractor(BuildStep):
    """Extracts and adds the build steps to the current builder.

    This step extracts the build steps from the `conf` property and adds them
    to the current builder. It also adds a step to build an image.
    """
    name = 'step extractor'
    logger = Logger('eve.steps.StepExtractor')

    def run(self):
        conf = self.getProperty('conf')
        stage_name = self.getProperty('stage_name')
        stage_conf = conf['stages'][stage_name]
        for step in stage_conf['steps']:
            step_type, params = dict.popitem(step)
            try:
                # try to see if the required step is imported or
                # defined in the current context
                _cls = globals()[step_type]
            except KeyError:
                # otherwise import the step from standars buildbot steps
                try:
                    _cls = getattr(steps, step_type)
                except AttributeError:
                    raise Exception('Could not load step %s' % step_type)

            # Replace the %(prop:*)s in the text with an Interpolate obj
            params = replace_with_interpolate(params)

            # hack to avoid putting clear passwords into the YAML file
            # for the HTTP step
            if issubclass(_cls, HTTPStep):
                pwd = params['auth'][1].replace('$', '')
                if pwd in environ:
                    params['auth'] = HTTPBasicAuth(
                        params['auth'][0], environ[pwd])

            # Hack! Buildbot does not accept unicode step names
            if 'name' in params and isinstance(params['name'], unicode):
                params['name'] = params['name'].encode('utf-8')

            step = _cls(**params)
            self.build.addStepsAfterLastStep([step])
            self.logger.debug('Add {step} with params : {params}',
                              step=step_type, params=params)
        return succeed(SUCCESS)


class BuildDockerImage(BuildStep):
    """Step to build a docker image.

    This step is usually the first step called before running a stage.
    The built docker image is then used to run all following steps of this
    stage.
    """
    logger = Logger('eve.steps.BuildDockerImage')
    docker_client = docker.Client(
        base_url=DOCKER_HOST,
        tls=TLS_CONFIG
    )

    def __init__(self, full_path, image_name, **kwargs):
        BuildStep.__init__(self, **kwargs)
        self.full_path = full_path
        self.image_name = image_name
        self.haltOnFailure = True  # pylint: disable=invalid-name

    @inlineCallbacks
    def run(self):
        # Capture the output of the docker build command in a log object
        stdio = yield self.addLog('stdio')
        stdio.addHeader(
            'Building docker image <%s> from %s on docker host %s\n' %
            (self.image_name, self.full_path, DOCKER_HOST))
        # assert the directory containing the dockerfile exists
        assert path.exists(self.full_path), \
            '%s does not exist' % self.full_path
        if not GIT_REPO.startswith('git://'):
            # git protocol is anonymous
            shutil.copy(GIT_KEY_PATH, self.full_path)
            shutil.copy(GIT_KEY_PATH + '.pub', self.full_path)
        self.setProperty('docker_image', self.image_name)
        stream = self.docker_client.build(path=self.full_path,
                                          tag=self.image_name)
        try:
            while True:
                output = yield threads.deferToThread(next, stream)
                output_lines = output.splitlines()
                for output_line in output_lines:
                    try:
                        line = json.loads(output_line)
                    except ValueError as ex:
                        stdio.addStderr('ERROR: could not parse '
                                        'docker output (json) \n'
                                        '  exception: %s\n'
                                        '  output: %s' % (ex, output_line))
                        continue
                    if 'error' in line:
                        stdio.addStderr(line['error'] + '\n')
                        stdio.finish()
                        returnValue(FAILURE)
                    elif 'stream' in line:
                        stdio.addStdout(line['stream'])
                    else:
                        self.logger.info(line)
        except StopIteration:
            stdio.finish()
            returnValue(SUCCESS)
        else:
            stdio.finish()
            returnValue(FAILURE)


class TriggerStages(BuildStep):
    """Start a list of stages."""

    def __init__(self, stage_names, **kwargs):
        self.stage_names = stage_names
        BuildStep.__init__(self, haltOnFailure=True)
        self.kwargs = kwargs
        if 'waitForFinish' not in kwargs:
            kwargs['waitForFinish'] = True

        self.name = 'prepare to trigger stage(s) %s' % ','.join(stage_names)

    def run(self):
        conf = self.getProperty('conf')
        preliminary_steps = []
        build_orders = []

        for stage_name in reversed(self.stage_names):
            worker_type = conf['stages'][stage_name]['worker']['type']
            assert worker_type in ('docker', 'openstack')
            if worker_type == 'docker':
                build_order = DockerBuildOrder(stage_name, conf, self)
            elif worker_type == 'openstack':
                # pylint bug 710
                # pylint: disable=redefined-variable-type
                build_order = OpenStackBuildOrder(stage_name, conf, self)
            else:
                return succeed(FAILURE)
            build_orders.append(build_order)
            preliminary_steps.extend(build_order.preliminary_steps)

        self.build.addStepsAfterCurrentStep(
            [ExecuteTriggerStages(build_orders, **self.kwargs)])
        self.build.addStepsAfterCurrentStep(preliminary_steps)

        return succeed(SUCCESS)


class BaseBuildOrder(object):  # pylint:disable=too-few-public-methods
    """Base class representing a build to trigger
    (Scheduler and properties)
    """
    scheduler = None

    def __init__(self, stage_name, conf, parent_step):
        self._stage = conf['stages'][stage_name]
        self._worker = self._stage['worker']
        self._parent_step = parent_step
        self.properties = dict((key, value) for key, value, origin in
                               parent_step.getProperties().asList())
        self.properties['stage_name'] = stage_name
        self.properties['git_reference'] = GIT_CACHE_DIR_CONTAINER
        self.preliminary_steps = []
        self.setup_properties()

    def setup_properties(self):
        """
        Setup additional properties
        :return: None
        """
        raise NotImplementedError()


# pylint: disable=too-few-public-methods
class DockerBuildOrder(BaseBuildOrder):
    """Base class representing a build to trigger on a Docker container
    (Scheduler, properties and docker config)
    """
    scheduler = DOCKER_SCHEDULER_NAME

    def setup_properties(self):
        docker_path = self._worker['path']
        full_docker_path = '%s/build/%s' % (
            self.properties['master_builddir'], docker_path)

        self.properties['docker_volumes'] = self._worker.get('volumes', [])
        self.properties['docker_volumes'].append(
            '%s:%s:ro' % (GIT_CACHE_DIR_HOST, GIT_CACHE_DIR_CONTAINER))
        self.properties['docker_volumes'].append(
            '%s:%s' % ('/var/run/docker.sock', '/var/run/docker.sock'))

        self.properties['docker_image'] = '%s-%06d' % (docker_path,
                                                       randint(0, 999999))

        self.preliminary_steps.append(BuildDockerImage(
            name=str('build docker image from %s' % docker_path),
            image_name=self.properties['docker_image'],
            full_path=full_docker_path,
        ))


class OpenStackBuildOrder(BaseBuildOrder):
    """Base class representing a build to trigger on an OpenStack instance
    (Scheduler, properties and OpenStack config)
    """
    scheduler = OPENSTACK_SCHEDULER_NAME

    def setup_properties(self):
        self.properties[
            'openstack_image'] = '1d3ea64f-1ead-4042-8cb6-8ceb523b6149'
        # https://developer.rackspace.com/docs/cloud-servers/v2/general-api-info/flavors/
        self.properties['openstack_flavor'] = 'general1-8'


class ExecuteTriggerStages(Trigger):
    """Allows to give specific parameter to every scheduler.

    This is a step that allows to start with the properties specified in the
    schedulerNames argument (tuple) instead of using the properties given in
    the set_properties/copy_properties parameters.
    """

    def __init__(self, build_orders, **kwargs):
        self._build_orders = build_orders
        if 'name' not in kwargs:
            kwargs['name'] = 'trigger stage(s) ' + ', '.join(
                [build_order.properties['stage_name']
                 for build_order in build_orders])
        Trigger.__init__(self, schedulerNames=['dummy'], **kwargs)

    def getSchedulersAndProperties(self):   # NOQA flake8 to ignore camelCase
        return [(build_order.scheduler, build_order.properties)
                for build_order in self._build_orders]


# #########################
# Bootstrap Sequence: Schedulers
# #########################
EVE_CONF['schedulers'] = []
EVE_CONF['schedulers'].append(AnyBranchScheduler(
    name=BOOTSTRAP_SCHEDULER_NAME,
    treeStableTimer=5,
    builderNames=[BOOTSTRAP_BUILDER_NAME]))

EVE_CONF['schedulers'].append(ForceScheduler(
    name="force-bootstrap",
    builderNames=[BOOTSTRAP_BUILDER_NAME]))

EVE_CONF['schedulers'].append(Try_Userpass(
    name='try-bootstrap',
    port=environ['TRY_PORT'],
    userpass=[("try", TRY_PWD)],
    builderNames=[BOOTSTRAP_BUILDER_NAME]))

# #########################
# Bootstrap Sequence: Build step factory
# #########################
BOOTSTRAP_FACTORY = BuildFactory()
if RAX_LOGIN:
    BOOTSTRAP_FACTORY.addStep(
        CloudfilesAuthenticate())
# Check out the source
BOOTSTRAP_FACTORY.addStep(
    Git(name='update git repo cache',
        workdir=GIT_CACHE_DIR_HOST,
        repourl=GIT_REPO,
        mode='incremental',
        submodules=True,
        shallow=False,
        retryFetch=True,
        haltOnFailure=True))
BOOTSTRAP_FACTORY.addStep(
    SetProperty(
        name='setting the master_builddir property',
        property='master_builddir',
        value=Property('builddir')))
BOOTSTRAP_FACTORY.addStep(
    Git(name='checkout git branch',
        repourl=GIT_CACHE_DIR_HOST,
        shallow=True,
        mode='incremental',
        haltOnFailure=True))
# Read conf from yaml file
BOOTSTRAP_FACTORY.addStep(ReadConfFromYaml())

# #########################
# Bootstrap Sequence: Builders
# #########################
EVE_CONF['builders'] = []
EVE_CONF['builders'].append(
    BuilderConfig(
        name=BOOTSTRAP_BUILDER_NAME,
        workernames=[lw.name for lw in LOCAL_WORKERS],
        factory=BOOTSTRAP_FACTORY))

# #########################
# Triggerable Sequence: Schedulers
# #########################
EVE_CONF['schedulers'].append(Triggerable(
    name=DOCKER_SCHEDULER_NAME,
    builderNames=[DOCKER_BUILDER_NAME]))

EVE_CONF['schedulers'].append(Triggerable(
    name=OPENSTACK_SCHEDULER_NAME,
    builderNames=[OPENSTACK_BUILDER_NAME]))


# #########################
# Triggerable Sequence: Builders
# #########################
for _builder, workers in (
        (DOCKER_BUILDER_NAME, DOCKER_WORKERS),
        (OPENSTACK_BUILDER_NAME, OPENSTACK_WORKERS)):
    factory = BuildFactory()
    # Extract steps from conf
    factory.addStep(StepExtractor(name='extract steps from yaml'))
    EVE_CONF['builders'].append(
        BuilderConfig(
            name=_builder,
            workernames=[w.name for w in workers],
            factory=factory,
            collapseRequests=False,
        ))

# #########################
# Collapsing requests
# #########################


@inlineCallbacks
# pylint:disable=unused-argument
def collapse_requests(master, builder, req1, req2):
    """any requests with the same branch can be merged"""

    can_be_collapsed = yield buildrequest.BuildRequest.canBeCollapsed(
        master, req1, req2)
    if can_be_collapsed and req1.reason == req2.reason:
        returnValue(True)
    else:
        returnValue(False)

EVE_CONF['collapseRequests'] = collapse_requests

# #########################
# Hacks/Bugfixes
# #########################
# Hack to fix a bug stating that LocalWorkers do not have a valid path_module
for w in EVE_CONF['workers']:
    w.path_module = namedModule("posixpath")


class TempSourceStamp(object):  # pylint: disable=too-few-public-methods
    """ This is a Hack to fix a bug where the git diff is sent as an str
    instead of unicode and triggers an exception
    """

    def asDict(self):  # pylint: disable=invalid-name,missing-docstring
        result = vars(self).copy()
        del result['ssid']
        del result['changes']
        if 'patch' in result and result['patch'] is None:
            result['patch'] = (None, None, None)
        result['patch_level'], result['patch_body'], result[
            'patch_subdir'] = result.pop('patch')
        result['patch_author'], result[
            'patch_comment'] = result.pop('patch_info')
        assert all(
            isinstance(val, (str, unicode, type(None), int))  # added str here
            for attr, val in result.items()
        ), result
        return result

buildrequest.TempSourceStamp = TempSourceStamp

# #########################
# Sentry Logging
# #########################


def init_sentry_logging():
    """Start logging of all failure to sentry."""
    client = Client(SENTRY_DSN,
                    transport=TwistedHTTPTransport,
                    auto_log_stacks=True)

    @provider(ILogObserver)
    def log_to_sentry(event):
        """Log a failure to Sentry."""
        if not event.get('isError') or 'failure' not in event:
            return
        failure = event['failure']
        client.captureException((failure.type, failure.value,
                                 failure.getTracebackObject()))

    globalLogPublisher.addObserver(log_to_sentry)

if SENTRY_DSN:
    init_sentry_logging()

# #########################
# Utils
# #########################


def replace_with_interpolate(obj):
    """Interpolate nested %(prop:obj)s in step arguments.

    Read step arguments from the yaml file and replaces them with
    interpolate objects when relevant so they can be replaced with
    properties when run.
    """

    if isinstance(obj, dict):
        return {k: replace_with_interpolate(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [replace_with_interpolate(elem) for elem in obj]
    elif isinstance(obj, str) and 'prop:' in obj:
        return Interpolate(obj)
    elif isinstance(obj, unicode) and 'prop:' in obj:
        return Interpolate(obj)
    else:
        return obj

# vim: ft=python
