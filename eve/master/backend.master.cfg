#!/usr/bin/env python
# coding: utf-8
"""Eve configuration file for buildbot.

This module is the core source code of eve.
It is in fact the configuration file for buildbot.
See the `Buildbot Manual`_ for more informations.

.. _Buildbot Manual:
    http://docs.buildbot.net/latest/manual/index.html
"""

import socket
import string
import time
from collections import OrderedDict
from fnmatch import fnmatch
from functools import wraps
from os import environ, path
from random import choice
from tempfile import mktemp, mkdtemp

import netifaces
import yaml
import buildbot
from buildbot.changes.gitpoller import GitPoller
from buildbot.config import BuilderConfig
from buildbot.locks import MasterLock
from buildbot.plugins import schedulers
from buildbot.process import buildrequest
import buildbot.process.build
from buildbot.process.buildstep import BuildStep
from buildbot.process.factory import BuildFactory
from buildbot.process.properties import Interpolate, Property
from buildbot.process.results import (
    CANCELLED, FAILURE, SUCCESS, SKIPPED
)
from buildbot.reporters.github import GitHubStatusPush
from buildbot.steps.master import MasterShellCommand, SetProperty
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.source.git import Git
from buildbot.steps.transfer import FileUpload
from buildbot.steps.trigger import Trigger
from buildbot.worker.local import LocalWorker
from packaging import version
from twisted.internet import defer
from twisted.logger import Logger
from twisted.python.reflect import namedModule

from common import filter_secrets, get_local_jobs, step_factory
from reporters.base import (
    BitbucketBuildStatusPush,
    HipChatBuildStatusPush
)
from sentry import init_sentry_logging
from steps.artifacts import Upload, CloudfilesAuthenticate, GetArtifactsFromPipeline # noqa: F401, pylint: disable=unused-import
from steps.docker import DockerBuild
from wamp import get_wamp_conf
from workers import docker, openstack


# Hack to not restart a worker substantiating on failure
buildbot.process.build.RETRY = FAILURE

MASTER_NAME = environ.pop('MASTER_NAME', 'master')

##########################
# Constants
##########################
BOOTSTRAP_BUILDER_NAME = 'bootstrap'
BOOTSTRAP_SCHEDULER_NAME = 'bootstrap-scheduler'
DOCKER_BUILDER_NAME = 'docker-%s' % MASTER_NAME
DOCKER_SCHEDULER_NAME = 'docker-scheduler-%s' % MASTER_NAME
OPENSTACK_BUILDER_NAME = 'openstack-%s' % MASTER_NAME
OPENSTACK_SCHEDULER_NAME = 'openstack-scheduler-%s' % MASTER_NAME
MAX_LOCAL_WORKERS = int(environ.get('MAX_LOCAL_WORKERS', 8))
MAX_DOCKER_WORKERS = MAX_LOCAL_WORKERS * 12
MAX_OPENSTACK_WORKERS = MAX_LOCAL_WORKERS * 10
EVE_FOLDER = 'eve'
EVE_MAIN_YAML = 'main.yml'
EVE_MAIN_YAML_FULL_PATH = '%s/%s' % (EVE_FOLDER, EVE_MAIN_YAML)
EVE_GIT_POLLING = False

OPENSTACK_IDENTITY_URL = 'https://identity.api.rackspacecloud.com/v2.0/'
OPENSTACK_REGION = environ.get('OPENSTACK_REGION', 'DFW')
OPENSTACK_TENANT = 984990
OPENSTACK_SSH_KEY = path.expanduser(
    environ.get('OPENSTACK_SSH_KEY', '~/.ssh/id_rsa'))
OPENSTACK_KEY_NAME = environ.get('OPENSTACK_KEY_NAME', 'eve-key-pair')
CLOUD_INIT_SCRIPT = environ.pop('CLOUD_INIT_SCRIPT', None)

##########################
# Set/Check environment variables
##########################

filter_secrets()

# git
GIT_REPO = environ.pop('GIT_REPO')
LOCAL_GIT_REPO = environ.pop('LOCAL_GIT_REPO', GIT_REPO)
GIT_REPO_SHORT = GIT_REPO.split('/')[-1].replace('.git', '')
GIT_CACHE_DIR_HOST = mkdtemp(prefix=GIT_REPO_SHORT)

# Sentry
SENTRY_DSN = environ.pop('SENTRY_DSN', None)

# docker
EXTERNAL_URL = environ.get('EXTERNAL_URL')
MASTER_FQDN = environ.pop('MASTER_FQDN')
WORKER_SUFFIX = environ.pop('WORKER_SUFFIX')

DOCKER_CERT_PATH = environ.get('DOCKER_CERT_PATH', None)
DOCKER_TLS_VERIFY = environ.get('DOCKER_TLS_VERIFY', '0')
if DOCKER_TLS_VERIFY != '0':
    # Checking that docker env vars are coherent
    assert path.isfile(path.join(DOCKER_CERT_PATH, 'ca.pem'))
    assert path.isfile(path.join(DOCKER_CERT_PATH, 'key.pem'))
    assert path.isfile(path.join(DOCKER_CERT_PATH, 'cert.pem'))

PROJECT_NAME = environ.pop('PROJECT_NAME')
PROJECT_URL = environ.pop('PROJECT_URL')

TRY_PWD = environ.pop('TRY_PWD')

# database
DB_URL = environ.pop('DB_URL', 'sqlite:///state.sqlite')

RAX_LOGIN = environ.pop('RAX_LOGIN', None)
RAX_PWD = environ.pop('RAX_PWD', None)

# artifacts
CLOUDFILES_URL = environ.pop(
    'CLOUDFILES_URL',
    'https://storage101.dfw1.clouddrive.com/v1/MossoCloudFS_984990/')
ARTIFACTS_URL = environ.pop(
    'ARTIFACTS_URL',
    'https://artifacts.devsca.com/builds')

ARTIFACTS_PREFIX = environ.get(
    'ARTIFACTS_PREFIX',
    'staging-')

Upload.CLOUDFILES_URL = CLOUDFILES_URL
Upload.ARTIFACTS_URL = ARTIFACTS_URL
Upload.ARTIFACTS_PREFIX = ARTIFACTS_PREFIX

MASTER_START_TIME = time.time()


##########################
# Project Identity
##########################
EVE_CONF = BuildmasterConfig = OrderedDict()  # pylint: disable=invalid-name
EVE_CONF['title'] = "the %s project" % PROJECT_NAME
EVE_CONF['titleURL'] = PROJECT_URL
EVE_CONF['buildbotURL'] = EXTERNAL_URL

##########################
# Multi Master
##########################
WAMP_ROUTER_URL = environ.pop('WAMP_ROUTER_URL')
WAMP_REALM = environ.pop('WAMP_REALM')
EVE_CONF['multiMaster'] = True
EVE_CONF['mq'] = get_wamp_conf(WAMP_ROUTER_URL, WAMP_REALM)

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that
# workers could connect to your master with this protocol.
# 'port' must match the value configured into the buildworkers (with their
# --master option)
EVE_CONF['protocols'] = {'pb': {'port': 'tcp:%s:interface=%s' % (
    environ['PB_PORT'], socket.gethostbyname(MASTER_FQDN))}}

# DB URL
EVE_CONF['db'] = {
    'db_url': DB_URL,
}

###########################
# Misc.
###########################

EVE_CONF['buildbotNetUsageData'] = None

# #########################
# Reporters
# #########################
# Reporters send the build status when finished

EVE_CONF['services'] = []

EVE_CONF['services'].append(HipChatBuildStatusPush(
    builders=[BOOTSTRAP_BUILDER_NAME]
))

if 'github' in PROJECT_NAME:
    EVE_CONF['services'].append(GitHubStatusPush(
        environ.pop('GITHUB_TOKEN'),
        builders=[BOOTSTRAP_BUILDER_NAME]))
else:
    EVE_CONF['services'].append(BitbucketBuildStatusPush(
        builders=[DOCKER_BUILDER_NAME, OPENSTACK_BUILDER_NAME]))


##########################
# Workers
##########################
EVE_CONF['workers'] = []


def password_generator(size=18, chars=string.ascii_uppercase + string.digits):
    return ''.join(choice(chars) for _ in range(size))

# Create MAX_LOCAL_WORKERS Local Workers that will:
# - bootstrap all product jobs
# - run extra scheduled jobs (setup at init)
LOCAL_WORKERS = []
for i in range(MAX_LOCAL_WORKERS):
    LOCAL_WORKERS.append(LocalWorker('lw%03d-%s' % (i, WORKER_SUFFIX)))
EVE_CONF['workers'].extend(LOCAL_WORKERS)


# Then create MAX_DOCKER_WORKERS Docker Workers that will do the real job
DOCKER_WORKERS = []
for i in range(MAX_DOCKER_WORKERS):
    DOCKER_WORKERS.append(
        docker.EveDockerLatentWorker(
            name='dw%03d-%s' % (i, WORKER_SUFFIX),
            password=password_generator(),
            master_fqdn=MASTER_FQDN,
            image=Property('docker_image'),
            keepalive_interval=300,
        ))
EVE_CONF['workers'].extend(DOCKER_WORKERS)


# Create MAX_OPENSTACK_WORKERS that will do the vm job
OPENSTACK_WORKERS = []
for i in range(MAX_OPENSTACK_WORKERS):
    OPENSTACK_WORKERS.append(
        openstack.EveOpenStackLatentWorker(
            name='ow%03d-%s' % (i, WORKER_SUFFIX),
            password=password_generator(),
            image=Property('openstack_image'),
            flavor=Property('openstack_flavor'),
            block_devices=None,
            os_auth_url=OPENSTACK_IDENTITY_URL,
            os_tenant_name=OPENSTACK_TENANT,
            os_username=RAX_LOGIN,
            os_password=RAX_PWD,
            region=OPENSTACK_REGION,
            cloud_init=CLOUD_INIT_SCRIPT,
            ssh_key=OPENSTACK_SSH_KEY,
            meta=None,
            masterFQDN=MASTER_FQDN,
            nova_args=dict(key_name=OPENSTACK_KEY_NAME),
            build_wait_timeout=0,  # do not reuse the instance
            keepalive_interval=300,
            client_version='2'))
EVE_CONF['workers'].extend(OPENSTACK_WORKERS)

##########################
# Change Sources
##########################
# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

EVE_CONF['change_source'] = []
if EVE_GIT_POLLING:
    EVE_CONF['change_source'].append(GitPoller(
        GIT_REPO,
        workdir='gitpoller-workdir',
        branches=True,
        pollinterval=900,
        pollAtLaunch=False,
        buildPushesWithNoCommits=True,
    ))


##########################
# Custom Build Steps
##########################
class ReadConfFromYaml(FileUpload):
    """Load the YAML file to `conf` property.

    This step Reads the YAML file and converts it to a `conf` property which
    is made available to the following steps.
    """
    logger = Logger('eve.steps.ReadConfFromYaml')

    def __init__(self, **kwargs):
        self.masterdest = mktemp()
        FileUpload.__init__(
            self,
            name='read %s' % EVE_MAIN_YAML_FULL_PATH,
            workersrc=EVE_MAIN_YAML_FULL_PATH,
            masterdest=self.masterdest,
            haltOnFailure=True,
            hideStepIf=lambda results, s: results == SUCCESS,
            **kwargs)

    @defer.inlineCallbacks
    def run(self):
        result = yield FileUpload.run(self)
        if result != SUCCESS:
            self.addCompleteLog('stderr', 'Could not find %s' %
                                EVE_MAIN_YAML_FULL_PATH)
            defer.returnValue(result)

        raw_conf = open(self.masterdest).read()
        self.addCompleteLog(EVE_MAIN_YAML_FULL_PATH, raw_conf)
        conf = yaml.load(raw_conf)

        # Extract Eve API version (call str() to support buggy yaml files)
        if conf and 'version' in conf.keys():
            eve_api_version = str(conf['version'])
        else:
            eve_api_version = '0.1'

        # Expand entries with several branch patterns
        try:
            branches = conf['branches']
        except (TypeError, KeyError):
            self.addCompleteLog('stderr', 'Could not find the branches field'
                                          'in %s' % EVE_MAIN_YAML_FULL_PATH)
            defer.returnValue(FAILURE)

        new_branches = {}
        for branch_patterns, branch_conf in branches.items():
            for branch_pattern in branch_patterns.split(','):
                new_branches[branch_pattern.strip()] = branch_conf
        conf['branches'] = new_branches
        self.setProperty('conf', conf, "ReadConfFromYaml")
        self.setProperty('master_start_time', MASTER_START_TIME)

        # Find the stage name from the branch name
        branch = self.getProperty('branch')
        if branch is None:
            branch = 'default'
        for branch_pattern, branch_conf in conf['branches'].items():
            self.logger.debug('Checking if <{branch}> matches <{pattern}>',
                              branch=branch, pattern=branch_pattern)
            if fnmatch(branch, branch_pattern):
                stage_name = branch_conf['stage']
                self.logger.debug('<{branch}> matched <{branch_pattern}>',
                                  branch=branch, branch_pattern=branch_pattern)
                break
        else:
            self.logger.debug('No branch match. Using default branch config.')
            try:
                stage_name = conf['branches']['default']['stage']
            except KeyError:
                self.addCompleteLog(
                    'stderr', 'Branch <%s> not covered by yaml file' % branch)
                defer.returnValue(CANCELLED)

        self.setProperty('stage_name', stage_name, 'ReadConfFromYaml Step')

        self.build.addStepsAfterCurrentStep([
            SetProperty(
                name='get the API version',
                property='eve_api_version',
                hideStepIf=lambda results, s: results == SUCCESS,
                value=eve_api_version),
            TriggerStages([
                stage_name
            ], waitForFinish=True, haltOnFailure=True)
        ])

        # compute artifact_name property starting from Eve API 0.2
        if version.parse(eve_api_version) >= version.parse('0.2'):
            docker_host_ip = '127.0.0.1'  # Dummy default value
            try:
                docker_addresses = netifaces.ifaddresses('docker0')
            except ValueError:
                pass
            else:
                try:
                    docker_host_ip = (docker_addresses[netifaces.AF_INET]
                                      [0]['addr'])
                except KeyError:
                    pass
            buildnumber = str(self.getProperty('buildnumber'))
            git_host, git_owner, git_slug = PROJECT_NAME.split('_', 2)
            self.build.addStepsAfterCurrentStep([
                SetProperty(
                    name='get the git host',
                    property='git_host',
                    hideStepIf=lambda results, s: results == SUCCESS,
                    value=git_host),
                SetProperty(
                    name='get the git owner',
                    property='git_owner',
                    hideStepIf=lambda results, s: results == SUCCESS,
                    value=git_owner),
                SetProperty(
                    name='get the repository name',
                    property='git_slug',
                    hideStepIf=lambda results, s: results == SUCCESS,
                    value=git_slug),
                SetPropertyFromCommand(
                    name='get the product version',
                    command=('./eve/get_product_version.sh 2> /dev/null'
                             ' || echo 0.0.0'),
                    hideStepIf=lambda results, s: results == SUCCESS,
                    property='product_version'),
                SetPropertyFromCommand(
                    name='get the commit short_revision',
                    command=Interpolate(
                        'git -C %(prop:master_builddir)s/build' +
                        ' rev-parse --verify --short ' +
                        branch
                    ),
                    hideStepIf=lambda results, s: results == SUCCESS,
                    property='commit_short_revision'),
                SetPropertyFromCommand(
                    name='get the commit timestamp',
                    command=Interpolate(
                        'date -u --date=@' +
                        '`git -C %(prop:master_builddir)s/build' +
                        ' show -s --format=%%ct ' + branch +
                        '` +%%y%%m%%d%%H%%M%%S'
                    ),
                    hideStepIf=lambda results, s: results == SUCCESS,
                    property='commit_timestamp'),
                SetProperty(
                    name='get the pipeline name',
                    property='pipeline',
                    hideStepIf=lambda results, s: results == SUCCESS,
                    value=stage_name),
                SetProperty(
                    name='get the b4nb',
                    property='b4nb',
                    hideStepIf=lambda results, s: results == SUCCESS,
                    value=buildnumber.zfill(8)),
                SetPropertyFromCommand(
                    name='set the artifacts base name',
                    command=Interpolate('echo %(prop:git_host)s'
                                        ':%(prop:git_owner)s'
                                        ':%(prop:git_slug)s'
                                        ':%(prop:artifacts_prefix)s'
                                        '%(prop:product_version)s'
                                        '.r%(prop:commit_timestamp)s'
                                        '.%(prop:commit_short_revision)s'),
                    hideStepIf=lambda results, s: results == SUCCESS,
                    property='artifacts_base_name'),
                SetPropertyFromCommand(
                    name='set the artifacts name',
                    command=Interpolate('echo %(prop:artifacts_base_name)s'
                                        '.%(prop:pipeline)s'
                                        '.%(prop:b4nb)s'),
                    hideStepIf=lambda results, s: results == SUCCESS,
                    property='artifacts_name'),
                SetProperty(
                    name='set the artifacts local reverse proxy',
                    property='artifacts_local_reverse_proxy',
                    hideStepIf=lambda results, s: results == SUCCESS,
                    value='http://' + docker_host_ip + ':1080/'),
                SetPropertyFromCommand(
                    name='set the artifacts private url',
                    command=Interpolate('echo http://' + docker_host_ip +
                                        ':1080/builds/'
                                        '%(prop:artifacts_name)s'),
                    hideStepIf=lambda results, s: results == SUCCESS,
                    property='artifacts_private_url'),
                SetPropertyFromCommand(
                    name='set the artifacts public url',
                    command=Interpolate('echo ' + ARTIFACTS_URL +
                                        '/%(prop:artifacts_name)s'),
                    hideStepIf=lambda results, s: results == SUCCESS,
                    property='artifacts_public_url'),
            ])

        defer.returnValue(SUCCESS)


class CancelCommand(MasterShellCommand):
    """Cancel a build according to result of command."""

    def processEnded(self, status_object):
        """If the return code is non-zero set build to CANCELLED."""
        if status_object.value.exitCode != 0:
            self.finished(CANCELLED)
        else:
            super(CancelCommand, self).processEnded(status_object)


class CancelNonTipBuild(CancelCommand):
    """Cancel if the current revision is not the tip of the branch."""

    def __init__(self, **kwargs):
        super(CancelNonTipBuild, self).__init__(
            name='check if build is relevant',
            command=Interpolate('[ "%(prop:revision)s" = "" ]'
                                '|| [ "$(git rev-list -1 %(prop:branch)s)"'
                                ' = "%(prop:revision)s" ]'),
            hideStepIf=lambda results, s: results == SUCCESS,
            workdir=GIT_CACHE_DIR_HOST,
        )


class CancelOldBuild(CancelCommand):
    """Cancel if the build is previous buildbot instance."""

    def __init__(self, **kwargs):
        super(CancelOldBuild, self).__init__(
            name='prevent unuseful restarts',
            hideStepIf=lambda results, s: results == SUCCESS,
            command=Interpolate('[ "' + str(MASTER_START_TIME) +
                                '" = "%(prop:master_start_time)s" ]'),
        )


class StepExtractor(BuildStep):
    """Extracts and adds the build steps to the current builder.

    This step extracts the build steps from the `conf` property and adds them
    to the current builder. It also adds a step to build an image.
    """
    name = 'step extractor'
    logger = Logger('eve.steps.StepExtractor')

    def run(self):
        conf = self.getProperty('conf')
        stage_name = self.getProperty('stage_name')
        stage_conf = conf['stages'][stage_name]
        for step in stage_conf['steps']:
            step_type, params = next(step.iteritems())
            bb_step = step_factory(globals(), step_type, **params)
            self.build.addStepsAfterLastStep([bb_step])
            self.logger.debug('Add {step} with params : {params}',
                              step=step_type, params=params)
        return defer.succeed(SUCCESS)


class TriggerStages(BuildStep):
    """Start a list of stages."""

    def __init__(self, stage_names, **kwargs_for_exec_trigger_stages):
        self.stage_names = stage_names

        kwargs_for_exec_trigger_stages.setdefault("waitForFinish", True)
        self._kwargs_for_exec_trigger_stages = kwargs_for_exec_trigger_stages

        kwargs = {
            'name': 'prepare {0} stage(s)'.format(len(self.stage_names)),
            'hideStepIf': lambda results, s: results == SUCCESS,
            'haltOnFailure': True,
        }
        super(TriggerStages, self).__init__(**kwargs)

    @defer.inlineCallbacks
    def run(self):
        conf = self.getProperty('conf')

        preliminary_steps = OrderedDict()
        build_orders = []

        for stage_name in self.stage_names:
            stage = conf['stages'][stage_name]
            worker = stage['worker']

            worker_type_to_class = {
                'docker': DockerBuildOrder,
                'openstack': OpenStackBuildOrder
            }
            build_order_class = worker_type_to_class.get(worker['type'])

            if build_order_class is None:
                defer.returnValue(FAILURE)

            build_order = build_order_class(
                stage_name, stage, worker, self
            )

            def set_property(result, build_order, propname):
                build_order.properties[propname] = result

            setprop_defers = []
            for propname, propvalue in build_order.properties.iteritems():
                setprop_defer = self.build.render(propvalue)
                setprop_defer.addCallback(set_property, build_order, propname)
                setprop_defers.append(setprop_defer)

            yield defer.gatherResults(setprop_defers)
            build_orders.append(build_order)

            for step in build_order.preliminary_steps:
                preliminary_steps[step] = ''

        self.build.addStepsAfterCurrentStep([
            ExecuteTriggerStages(
                build_orders, **self._kwargs_for_exec_trigger_stages
            )
        ])
        self.build.addStepsAfterCurrentStep(list(preliminary_steps))

        defer.returnValue(SUCCESS)


class BaseBuildOrder(object):
    """Base class representing a build to trigger
    (Scheduler and properties)
    """
    scheduler = None

    def __init__(self, stage_name, stage, worker, parent_step):
        self._stage_name = stage_name
        self._stage = stage
        self._worker = worker
        self._parent_step = parent_step

        self.properties = {}
        self.preliminary_steps = []

        self.setup_properties()

    def setup_properties(self):
        """
        Setup additional properties
        :return: None
        """
        properties = self._parent_step.getProperties()
        self.properties = {
            k: v[0] for k, v in properties.asDict().iteritems()
        }
        self.properties.update({
            'stage_name': self._stage_name,
            'reason': self._stage_name,
            'git_reference': GIT_REPO,
            'git_repo': GIT_REPO,
        })


class DockerBuildOrder(BaseBuildOrder):
    """Base class representing a build to trigger on a Docker container
    (Scheduler, properties and docker config)
    """
    scheduler = DOCKER_SCHEDULER_NAME

    def setup_properties(self):
        super(DockerBuildOrder, self).setup_properties()

        self.properties['docker_volumes'] = self._worker.get('volumes', []) + [
            '{0}:{0}'.format('/var/run/docker.sock')
        ]

        self.properties['worker_path'] = self._worker.get('path')
        if self.properties['worker_path'] is None:
            self.properties['docker_image'] = Interpolate(
                self._worker['image'])
            return

        full_docker_path = '%s/build/%s' % (
            self.properties['master_builddir'],
            self.properties['worker_path'],
        )
        self.properties['docker_image'] = '%s-%06d' % (
            self.properties['worker_path'],
            self.properties['buildnumber'],
        )

        common_args = {
            "image": self.properties['docker_image'],
            "dockerfile": self._worker.get("dockerfile"),
            "workdir": full_docker_path,
            "build_args": {
                "BUILDBOT_VERSION": buildbot.version
            },
            "labels": {
                "eve.build.ts": "{0:.0f}".format(time.time())
            }
        }

        self.preliminary_steps.append(DockerBuild(
            name='build docker image from {0}'.format(
                self.properties['worker_path']
            ),
            flunkOnFailure=False,
            haltOnFailure=False,
            **common_args
        ))

        # Workaround EVE-215
        # The previous docker build could fail because:
        # - the dockerfile is incorrect
        # - the remote sources are unavailable
        # - or we hit EVE-215, and the previous image in cache
        #   is not reliable
        # In all cases, try again once and ignore cached images (nocache)

        def is_prev_build_failed(step):
            properties = step.build.getProperties()
            prec_failed_image = properties.getProperty('DockerBuildFailed', '')
            return prec_failed_image == step.image

        self.preliminary_steps.append(DockerBuild(
            name='docker build retry from {0}'.format(
                self.properties['worker_path']
            ),
            is_retry=True,
            hideStepIf=lambda results, s: results == SKIPPED,
            doStepIf=is_prev_build_failed,
            **common_args
        ))
        # end of workaround


class OpenStackBuildOrder(BaseBuildOrder):
    """Base class representing a build to trigger on an OpenStack instance
    (Scheduler, properties and OpenStack config)
    """
    scheduler = OPENSTACK_SCHEDULER_NAME

    DEFAULT_IMAGE = 'Ubuntu 14.04 LTS (Trusty Tahr) (PVHVM)'
    DEFAULT_FLAVOR = 'general1-4'
    """See https://developer.rackspace.com/docs/cloud-servers/v2/general-api-info/flavors/."""  # noqa: E501, pylint: disable=line-too-long

    def setup_properties(self):
        super(OpenStackBuildOrder, self).setup_properties()

        self.properties.update({
            'worker_path': self._worker['path'],
            'openstack_image': self._worker.get('image', self.DEFAULT_IMAGE),
            'openstack_flavor': self._worker.get('flavor', self.DEFAULT_FLAVOR)
        })


class ExecuteTriggerStages(Trigger):
    """Execute simultaneously multiple build steps.

    It's a fake Trigger stage which run multiple BuildStep simultaneously.
    """

    def __init__(self, build_orders, *args, **kwargs):
        kwargs.update({
            "schedulerNames": ["foo"]
        })
        super(ExecuteTriggerStages, self).__init__(*args, **kwargs)

        self._build_orders = build_orders

    def getSchedulersAndProperties(self):
        return [{
            'sched_name': build_order.scheduler,
            'props_to_set': build_order.properties,
            'unimportant': False
        } for build_order in self._build_orders]


# #########################
# Bootstrap Sequence: Build step factory
# #########################
BOOTSTRAP_FACTORY = BuildFactory()
if RAX_LOGIN:
    BOOTSTRAP_FACTORY.addStep(
        CloudfilesAuthenticate(rax_login=RAX_LOGIN, rax_pwd=RAX_PWD))

# Check out the source
GIT_CACHE_UPDATE_LOCK = MasterLock("git_cache_update")
BOOTSTRAP_FACTORY.addStep(
    ShellCommand(name='update git repo cache',
                 workdir=GIT_CACHE_DIR_HOST,
                 command=(
                     'git clone --mirror --recursive %s . || '
                     'git remote update' % LOCAL_GIT_REPO),
                 locks=[GIT_CACHE_UPDATE_LOCK.access('exclusive')],
                 hideStepIf=lambda results, s: results == SUCCESS,
                 haltOnFailure=True))

BOOTSTRAP_FACTORY.addStep(CancelNonTipBuild())

BOOTSTRAP_FACTORY.addStep(
    SetPropertyFromCommand(
        name='get the git sha1 from the branch name',
        command=Interpolate('cd ' + GIT_CACHE_DIR_HOST +
                            ' && git rev-list -1 %(prop:branch)s'),
        hideStepIf=lambda results, s: results == SUCCESS,
        property='revision'))

BOOTSTRAP_FACTORY.addStep(
    SetProperty(
        name='setting the master_builddir property',
        property='master_builddir',
        hideStepIf=lambda results, s: results == SUCCESS,
        value=Property('builddir')))

BOOTSTRAP_FACTORY.addStep(
    Git(name='checkout git branch',
        repourl=GIT_CACHE_DIR_HOST,
        shallow=True,
        retry=(60, 10),
        submodules=True,
        mode='incremental',
        hideStepIf=lambda results, s: results == SUCCESS,
        haltOnFailure=True))
# Read conf from yaml file
BOOTSTRAP_FACTORY.addStep(ReadConfFromYaml())

# #########################
# Bootstrap Sequence: Builders
# #########################
EVE_CONF['builders'] = []
EVE_CONF['builders'].append(
    BuilderConfig(
        name=BOOTSTRAP_BUILDER_NAME,
        workernames=[lw.name for lw in LOCAL_WORKERS],
        factory=BOOTSTRAP_FACTORY,
        properties={
            'artifacts_url': ARTIFACTS_URL,
            'artifacts_prefix': ARTIFACTS_PREFIX,
        },
    )
)

# #########################
# Triggerable Sequence: Schedulers
# #########################
EVE_CONF['schedulers'] = []

EVE_CONF['schedulers'].append(schedulers.Triggerable(
    name=DOCKER_SCHEDULER_NAME,
    builderNames=[DOCKER_BUILDER_NAME]))

EVE_CONF['schedulers'].append(schedulers.Triggerable(
    name=OPENSTACK_SCHEDULER_NAME,
    builderNames=[OPENSTACK_BUILDER_NAME]))

# #########################
# Triggerable Sequence: Builders
# #########################
for _builder, workers in (
        (DOCKER_BUILDER_NAME, DOCKER_WORKERS),
        (OPENSTACK_BUILDER_NAME, OPENSTACK_WORKERS)):
    factory = BuildFactory()
    factory.addStep(CancelOldBuild())
    # Extract steps from conf
    factory.addStep(StepExtractor(
        name='extract steps from yaml',
        hideStepIf=lambda results, s: results == SUCCESS
    ))

    EVE_CONF['builders'].append(
        BuilderConfig(
            name=_builder,
            workernames=[w.name for w in workers],
            factory=factory,
            collapseRequests=False,
        )
    )

# ########################
# Load local jobs
# ########################
extra_builders, extra_schedulers = get_local_jobs(
    LOCAL_WORKERS,
    suffix="-{0}".format(MASTER_NAME)
)
EVE_CONF["builders"] += extra_builders
EVE_CONF["schedulers"] += extra_schedulers

# #########################
# Collapsing requests
# #########################
EVE_CONF['collapseRequests'] = False

# #########################
# Hacks/Bugfixes
# #########################

# Hack to allow build step name interpolation


def hide_interpolatable_name(func):
    """Hide the interpolatable name to be later rendered."""
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        self._interpolatable_name = kwargs.pop('name', None) or self.name
        self.name = str(self._interpolatable_name)
        return func(self, *args, **kwargs)
    return wrapper


def render_interpolatable_name(func):
    """Render the hidden interpolatable name before proceeding."""
    @wraps(func)
    @defer.inlineCallbacks
    def wrapper(self, *args, **kwargs):
        if isinstance(self._interpolatable_name, Interpolate):
            finished = self.build.render(self._interpolatable_name)

            def set_name(res):
                self.name = res
            finished.addCallback(set_name)
            yield finished
        res = yield func(self, *args, **kwargs)
        defer.returnValue(res)
    return wrapper

BuildStep.__init__ = hide_interpolatable_name(BuildStep.__init__)
BuildStep.startStep = render_interpolatable_name(BuildStep.startStep)

# Hack to fix a bug stating that LocalWorkers do not have a valid path_module
for w in EVE_CONF['workers']:
    w.path_module = namedModule("posixpath")


# Compressed logs generate a lot of issues like this :
# 2016-08-28 14:17:22+0000 [-] /root/eve/workspaces/ring/venv/local/lib/
# python2.7/site-packages/sqlalchemy/engine/default.py:451:
# _mysql_exceptions.Warning: Invalid utf8 character string: 'DAC554'
# This hack fixes them by disabling log compression
EVE_CONF['logCompressionMethod'] = 'raw'


class TempSourceStamp(object):
    """ This is a Hack to fix a bug where the git diff is sent as an str
    instead of unicode and triggers an exception
    """

    def asDict(self):  # pylint: disable=invalid-name,missing-docstring
        result = vars(self).copy()
        del result['ssid']
        del result['changes']
        if 'patch' in result and result['patch'] is None:
            result['patch'] = (None, None, None)
        result['patch_level'], result['patch_body'], result[
            'patch_subdir'] = result.pop('patch')
        result['patch_author'], result[
            'patch_comment'] = result.pop('patch_info')
        assert all(
            isinstance(val, (str, unicode, type(None), int))  # added str here
            for attr, val in result.items()
        ), result
        return result

buildrequest.TempSourceStamp = TempSourceStamp


# #########################
# Sentry Logging
# #########################

SENTRY_DSN = environ.pop('SENTRY_DSN', None)
if SENTRY_DSN:
    init_sentry_logging(SENTRY_DSN)

# #########################
# Set global properties
# #########################

EVE_CONF["properties"] = {
    "buildbot_version": buildbot.version
}
