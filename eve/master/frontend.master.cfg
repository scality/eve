#!/usr/bin/env python
# coding: utf-8
"""Eve configuration file for buildbot.

This module is the core source code of eve.
It is in fact the configuration file for buildbot.
See the `Buildbot Manual`_ for more informations.

.. _Buildbot Manual:
    http://docs.buildbot.net/latest/manual/index.html
"""

import json
import re
import subprocess
import time
from collections import OrderedDict
from os import environ

from buildbot.changes.gitpoller import GitPoller
from buildbot.process import buildrequest
from buildbot.process.results import (CANCELLED, EXCEPTION, FAILURE, RETRY,
                                      SKIPPED, SUCCESS, WARNINGS, Results)
from buildbot.reporters import utils
from buildbot.reporters.http import HttpStatusPushBase
from buildbot.www.authz import Authz, endpointmatchers, roles
from buildbot.www.hooks import bitbucket
from buildbot.www.oauth2 import GoogleAuth
from dateutil.parser import parse as dateparse
from requests.auth import HTTPBasicAuth
from twisted.internet import defer
from twisted.internet.threads import deferToThread
from twisted.logger import Logger
from twisted.python import log

from sentry import init_sentry_logging
from wamp import get_wamp_conf

##########################
# Constants
##########################
BOOTSTRAP_BUILDER_NAME = 'bootstrap'
EVE_GIT_POLLING = False


##########################
# Set/Check environment variables
##########################

# store 'secret' environment variables in a separate dictionary
SECRETS = {}

for key in dict(environ):
    if key.startswith('SECRET_'):
        SECRETS[key.lstrip('SECRET_')] = environ.pop(key)

# git
GIT_REPO = environ.pop('GIT_REPO')

EXTERNAL_URL = environ.pop('EXTERNAL_URL')


# bitbucket
EVE_BITBUCKET_LOGIN = environ.pop('EVE_BITBUCKET_LOGIN')
EVE_BITBUCKET_PWD = environ.pop('EVE_BITBUCKET_PWD')

BITBUCKET_PUB_KEY = environ.get('BITBUCKET_PUB_KEY', None)

OAUTH2_CLIENT_ID = environ.pop('OAUTH2_CLIENT_ID')
OAUTH2_CLIENT_SECRET = environ.pop('OAUTH2_CLIENT_SECRET')

PROJECT_NAME = environ.pop('PROJECT_NAME')
PROJECT_URL = environ.pop('PROJECT_URL')

TRY_PWD = environ.pop('TRY_PWD')

# database
DB_URL = environ.pop('DB_URL', 'sqlite:///state.sqlite')

# artifacts
CLOUDFILES_URL = environ.pop(
    'CLOUDFILES_URL',
    'https://storage101.dfw1.clouddrive.com/v1/MossoCloudFS_984990/')
ARTIFACTS_URL = environ.pop(
    'ARTIFACTS_URL',
    'https://artifacts.devsca.com/builds')

ARTIFACTS_PREFIX = environ.pop('ARTIFACTS_PREFIX', 'staging-')

ARTIFACTS_LOGIN = environ.pop('ARTIFACTS_LOGIN', None)
ARTIFACTS_PWD = environ.pop('ARTIFACTS_PWD', None)

MASTER_START_TIME = time.time()


##########################
# Project Identity
##########################
EVE_CONF = BuildmasterConfig = OrderedDict()  # pylint: disable=invalid-name
EVE_CONF['title'] = "the %s project" % PROJECT_NAME
EVE_CONF['titleURL'] = PROJECT_URL
EVE_CONF['buildbotURL'] = EXTERNAL_URL

##########################
# Multi Master
##########################
WAMP_ROUTER_URL = environ.pop('WAMP_ROUTER_URL')
WAMP_REALM = environ.pop('WAMP_REALM')
EVE_CONF['multiMaster'] = True
EVE_CONF['mq'] = get_wamp_conf(WAMP_ROUTER_URL, WAMP_REALM)

##########################
# HipChat Configuration
##########################
REPO_ICON = 'http://www.packal.org/sites/default/files/public/styles/icon_' \
            'large/public/workflow-files/netdeanishealfred-git-repos/icon/' \
            'icon.png?itok=1zkuMgPa'
BRANCH_ICON = 'http://plainicon.com/dboard/userprod/2800_a1826/prod_thumb/' \
              'plainicon.com-50219-512px-201.png'
CLOCK_ICON = 'https://image.freepik.com/free-icon/clock-of-circular-shape-at' \
             '-two-o-clock_318-48022.jpg'

HIPCHAT_TOKEN = environ.pop('HIPCHAT_TOKEN')
HIPCHAT_ROOM = environ.pop('HIPCHAT_ROOM')

##########################
# Web UI
##########################
# Create a basic auth website with the waterfall view and the console view


def getChanges(request, options=None):
    """Catch a POST request from BitBucket and start a build process

    Check the URL below if you require more information about payload
    https://confluence.atlassian.com/display/BITBUCKET/POST+Service+Management

    :param request: the http request Twisted object
    :param options: additional options
    """

    log.msg('Processing changes from bitbucket')
    payload = json.loads(request.content.read())
    repo_url = payload['repository']['links']['html']['href']
    log.msg("repo_url:", repo_url)
    project = payload['repository']['project']['name']

    changes = []
    commits = set()
    for change in payload['push']['changes']:
        new = change.get('new', None)
        if new is None:
            continue
        if new['type'] != u'branch':
            continue
        log.msg('found branch change!')
        target = new['target']

        if target['hash'] in commits:
            # FIXME: temporary fix to have only one build per commit
            log.msg('skipping branch %s: commit %s already '
                    'scheduled for building' % (new['name'], target['hash']))
            continue

        commits.add(target['hash'])
        change = {
            'author': target['author']['raw'],
            'branch': new['name'],
            'files': [],
            'comments': target['message'],
            'revision': target['hash'],
            'revlink': target['links']['html']['href'],
            'repository': repo_url,
            'project': project
        }
        log.msg(change)

        changes.append(change)

    return (changes, payload['repository']['scm'])


bitbucket.getChanges = getChanges

EVE_CONF['www'] = dict(
    port=environ['HTTP_PORT'],
    plugins=dict(waterfall_view={}, console_view={}),
    auth=GoogleAuth(OAUTH2_CLIENT_ID,
                    OAUTH2_CLIENT_SECRET),
    change_hook_dialects={'bitbucket': True},
)

# Limit write operations to the OAUTH2_CLIENT_ID account except for tests


class DeveloperRoleIfConnected(roles.RolesFromBase):
    """ Sets the 'developer' role to all authenticated users"""

    def getRolesFromUser(self, userDetails):
        if 'email' in userDetails:  # and userDetails['email']:
            return ['developer']
        return []

if OAUTH2_CLIENT_ID != 'test':
    EVE_CONF['www']['authz'] = Authz(
        allowRules=[
            endpointmatchers.AnyEndpointMatcher(role='developer'),
        ],
        roleMatchers=[
            DeveloperRoleIfConnected()
        ]
    )

# DB URL
EVE_CONF['db'] = {
    'db_url': DB_URL,
}

###########################
# Misc.
###########################

EVE_CONF['buildbotNetUsageData'] = None


# #########################
# Reporters
# #########################
# Reporters send the build status when finished

class BaseBuildStatusPush(HttpStatusPushBase):
    """
    Base class for pushing build status
    """
    neededDetails = dict(wantProperties=True, wantSteps=True)
    RESULT_COLOR_CORRESP = {
        SUCCESS: 'green',
        WARNINGS: 'orange',
        FAILURE: 'red',
        SKIPPED: 'white',
        EXCEPTION: 'purple',
        RETRY: 'purple',
        CANCELLED: 'pink'}

    @defer.inlineCallbacks
    def getDetailsForTriggeredBuilds(self, build):
        for step in build['steps']:
            step.setdefault('triggered_builds', [])
            for url in step['urls']:
                matched = re.search(r'builders/(\d+)/builds/(\d+)', url['url'])
                if not matched:
                    continue
                trig_build = yield self.master.db.builds.getBuildByNumber(*matched.groups())
                trig_build['buildid'] = trig_build['id']
                yield utils.getDetailsForBuild(self.master,
                                               trig_build,
                                               **self.neededDetails)
                yield self.getDetailsForTriggeredBuilds(trig_build)
                step['triggered_builds'].append(trig_build)

    @defer.inlineCallbacks
    def getMoreInfoAndSend(self, build):
        yield utils.getDetailsForBuild(self.master, build, **self.neededDetails)
        if self.filterBuilds(build):
            yield self.getDetailsForTriggeredBuilds(build)
            yield self.send(build)

    def gather_data(self, build):
        """
        Gathers data to be used in build status
        :param build: The build dictionary
        :return: (key, result, title, summary, description)
        """
        key = 'pre-merge'  # fixme: this should be set dynamically
        src = build['buildset']['sourcestamps'][0]
        self.repo = src['repository'].strip('/').split('/')[-1].\
            replace('.git', '')
        branch = src['branch']
        title = 'build #%s' % build['buildid']
        summary = '(%s) build #%s on %s:%s ' % (
            build['state_string'], build['buildid'], self.repo, branch)

        self.add_tag('branch', branch, BRANCH_ICON, color='blue')
        self.add_tag('repository', self.repo, REPO_ICON, color='blue')

        result = build['results']
        description = 'in progress...'
        if result is not None:
            description = 'Hooray!'
            duration = build['complete_at'] - build['started_at']
            summary += '[%s]' % Results[result]
            if result != SUCCESS:
                description = Results[result] + ' in step(s): ' + ', '.join(
                    self.getStepsWithResult(build))

            self.add_tag('result', Results[result], None,
                         color=self.RESULT_COLOR_CORRESP[result])
            self.add_tag('duration', '%d seconds' % duration, CLOCK_ICON,
                         color='gray')

        return key, result, title, summary, description

    def getStepsWithResult(self, build):
        res = []
        for step in build['steps']:
            if step['results'] != build['results']:
                continue
            if step.get('triggered_builds'):
                for trig_build in step['triggered_builds']:
                    if trig_build['results'] != build['results']:
                        continue
                    for step_chain in self.getStepsWithResult(trig_build):
                        res.append('%s -> %s' % (trig_build['properties']['stage_name'][0],
                                                 step_chain))
            else:
                res.append(step['name'])
        return res

    def add_tag(self, name, value, icon, color=None):
        """
        Add a tag (name+value) to the status
        :param name: The name of the tag
        :param value: The value of the tag
        :param icon: a square image url (can be None) (HipChat Only)
        :param color: The color of the tag (HipChat Only)
        :return: None
        """
        raise NotImplementedError()


class HipChatBuildStatusPush(BaseBuildStatusPush):
    """Send build result to HipChat build status API."""
    name = "HipChatBuildStatusPush"
    logger = Logger('eve.steps.HipChatBuildStatusPush')
    attributes = []
    COLOR_STYLE_CORRESP = {
        'green': 'lozenge-success',
        'orange': 'lozenge-current',
        'red': 'lozenge-error',
        'white': 'lozenge',
        'purple': 'lozenge-error',
        'pink': 'lozenge-error',
        'brown': 'lozenge-moved',
        'blue': 'lozenge-complete',
        'gray': 'lozenge'}
    HIPCHAT_COLOR_CORRESP = {
        SUCCESS: 'green',
        WARNINGS: 'yellow',
        FAILURE: 'red',
        SKIPPED: 'gray',
        EXCEPTION: 'purple',
        RETRY: 'purple',
        CANCELLED: 'gray',
        None: 'gray'}

    def add_tag(self, name, value, icon, color=None):
        attr = dict(label=name, value=dict(label=value))
        if color in self.COLOR_STYLE_CORRESP:
            attr['value']['style'] = self.COLOR_STYLE_CORRESP[color]
        if icon:
            attr['value']['icon'] = dict(url=icon)
        self.attributes.append(attr)

    @defer.inlineCallbacks
    def send(self, build):
        """Send build status to HipChat."""

        self.attributes = []
        key, result, title, summary, description = self.gather_data(build)

        headers = {
            'content-type': 'application/json',
            'authorization': 'Bearer %s' % HIPCHAT_TOKEN}

        card = dict(
            style='application',
            url=build['url'],
            format='medium',
            id=key,
            title=title,
            description=dict(format='text', value=description),
            attributes=self.attributes,
            activity=dict(html=summary))

        data = dict(
            message=summary,
            name=key,
            message_format='text',
            notify=True,
            card=card,
            color=self.HIPCHAT_COLOR_CORRESP[result])

        url = 'https://api.hipchat.com/v2/room/%s/notification' % HIPCHAT_ROOM

        if EVE_BITBUCKET_LOGIN == 'test':
            return  # Don't really push status for tests
        response = yield self.session.post(url, headers=headers, json=data)
        if response.status_code != 204:
            raise Exception(
                "{response.status_code}: unable to send status to HipChat: "
                "{url}\nRequest:\n{request}\nResponse:\n{response.content}".
                format(request=data, response=response, url=url))
        self.logger.info("HipChat status sent")

# The status push works only on the main builder (bootstrap)
EVE_CONF['services'] = [HipChatBuildStatusPush(
    builders=[BOOTSTRAP_BUILDER_NAME])]


class BitbucketBuildStatusPush(BaseBuildStatusPush):
    """Send build result to bitbucket build status API."""
    name = "BitbucketBuildStatusPush"
    description_suffix = ''
    logger = Logger('eve.steps.BitbucketBuildStatusPush')
    BITBUCKET_STATUS_CORRESP = {
        SUCCESS: 'SUCCESSFUL',
        WARNINGS: 'SUCCESSFUL',
        FAILURE: 'FAILED',
        SKIPPED: 'FAILED',
        EXCEPTION: 'FAILED',
        CANCELLED: 'FAILED',
        RETRY: 'INPROGRESS',
        None: 'INPROGRESS'}

    def forge_url(self, build):
        """Forge the BB API URL on which the build status will be posted."""
        sha1 = build['buildset']['sourcestamps'][0]['revision']
        return 'https://api.bitbucket.org/2.0/repositories/' \
               '%(repo_owner)s/%(repo_name)s/commit/%(sha1)s/statuses/build' \
               % {
                   'repo_owner': 'scality',
                   'repo_name': self.repo,
                   'sha1': sha1
               }

    def add_tag(self, name, value, icon, color=None):
        name_value = '[%s: %s]' % (name, value)
        self.description_suffix = name_value + self.description_suffix

    @defer.inlineCallbacks
    def send(self, build):
        """Send build status to Bitbucket."""
        self.description_suffix = ''
        key, result, _, summary, description = self.gather_data(build)
        data = {
            'state': self.BITBUCKET_STATUS_CORRESP[result],
            'key': key,
            "name": summary,
            "url": build['url'],
            "description": description + self.description_suffix
        }
        auth = HTTPBasicAuth(EVE_BITBUCKET_LOGIN, EVE_BITBUCKET_PWD)
        url = self.forge_url(build)
        if 'eve.devsca.com' not in EXTERNAL_URL:
            self.logger.info("Bitbucket status not sent (not in prod) "
                             "(%s:%s on %s)" % (
                                self.BITBUCKET_STATUS_CORRESP[result],
                                key,
                                url))
            return  # Don't really push status for tests
        response = yield self.session.post(
            url, json=data, auth=auth)
        # 200 means that the key already exists
        # 201 means that the key has been created successfully
        if response.status_code not in (200, 201):
            raise Exception(
                "{response.status_code}: unable to send status to Bitbucket: "
                "{url}\nRequest:\n{request}\nResponse:\n{response.content}".
                format(request=data, response=response, url=url))
        self.logger.info("Bitbucket status sent (%s:%s on %s)" % (
            self.BITBUCKET_STATUS_CORRESP[result],
            key,
            url))

# The status push works only on the main builder (bootstrap)
EVE_CONF['services'].append(BitbucketBuildStatusPush(
    builders=[BOOTSTRAP_BUILDER_NAME]))


##########################
# Change Sources
##########################
# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

EVE_CONF['change_source'] = []
if EVE_GIT_POLLING:
    EVE_CONF['change_source'].append(GitPoller(
        GIT_REPO,
        workdir='gitpoller-workdir',
        branches=True,
        pollinterval=900,
        pollAtLaunch=False,
        buildPushesWithNoCommits=True,
    ))


# #########################
# Collapsing requests
# #########################
EVE_CONF['collapseRequests'] = False


class TempSourceStamp(object):  # pylint: disable=too-few-public-methods
    """ This is a Hack to fix a bug where the git diff is sent as an str
    instead of unicode and triggers an exception
    """

    def asDict(self):  # pylint: disable=invalid-name,missing-docstring
        result = vars(self).copy()
        del result['ssid']
        del result['changes']
        if 'patch' in result and result['patch'] is None:
            result['patch'] = (None, None, None)
        result['patch_level'], result['patch_body'], result[
            'patch_subdir'] = result.pop('patch')
        result['patch_author'], result[
            'patch_comment'] = result.pop('patch_info')
        assert all(
            isinstance(val, (str, unicode, type(None), int))  # added str here
            for attr, val in result.items()
        ), result
        return result

buildrequest.TempSourceStamp = TempSourceStamp


# #########################
# Sentry Logging
# #########################

SENTRY_DSN = environ.pop('SENTRY_DSN', None)
if SENTRY_DSN:
    init_sentry_logging(SENTRY_DSN)


# #########################
# Bootstrap Sequence: Schedulers
# #########################
BOOTSTRAP_SCHEDULER_NAME = 'bootstrap-scheduler'
from buildbot.plugins import util
from buildbot.scheduler import AnyBranchScheduler
from buildbot.changes.filter import ChangeFilter
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.schedulers.trysched import Try_Userpass


class EveForceScheduler(ForceScheduler):
    @defer.inlineCallbacks
    def gatherPropertiesAndChanges(self, collector, **kwargs):
        d = super(EveForceScheduler, self).gatherPropertiesAndChanges(
            collector, **kwargs)
        properties, changeids, sourcestamps = yield d

        yield deferToThread(self.add_missing_revisions, sourcestamps)

        defer.returnValue((properties, changeids, sourcestamps))

    def add_missing_revisions(self, sourcestamps):
        for _, sourcestamp in sourcestamps.iteritems():
            if not sourcestamp['revision']:
                # Retrieve revision from branch for sourcestamps without one
                sourcestamp['revision'] = subprocess.check_output(
                    ['git', 'ls-remote', GIT_REPO, sourcestamp['branch']],
                    stderr=subprocess.PIPE,
                ).split()[0]


EVE_CONF['schedulers'] = []
EVE_CONF['schedulers'].append(AnyBranchScheduler(
    name=BOOTSTRAP_SCHEDULER_NAME,
    treeStableTimer=5,
    change_filter=ChangeFilter(branch_re='.+'),  # build only branches
    builderNames=[BOOTSTRAP_BUILDER_NAME]))

EVE_CONF['schedulers'].append(EveForceScheduler(
    name='force',
    builderNames=[BOOTSTRAP_BUILDER_NAME],
    reason=util.StringParameter(name='reason',
                                label='Reason:',
                                default='force build',
                                size=20),
    codebases=[
        util.CodebaseParameter(
            '',
            branch=util.StringParameter(name='branch',
                                        label='Branch:',
                                        required=True),
            revision=util.FixedParameter(name='revision',
                                         default=''),
            repository=util.FixedParameter(name='repository',
                                           default=PROJECT_URL),
            project=util.FixedParameter(name='project',
                                        default=PROJECT_NAME),
        )
    ],
))

EVE_CONF['schedulers'].append(Try_Userpass(
    name='try',
    port=environ['TRY_PORT'],
    userpass=[("try", TRY_PWD)],
    builderNames=[BOOTSTRAP_BUILDER_NAME]))
