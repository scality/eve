#!/usr/bin/env python

from __future__ import print_function

import io
import json
import os
import sys
import tarfile
import tempfile
from time import sleep
from uuid import uuid4

import requests
import urllib3


def process_dockerfile(dockerfile, path):
    """Read the dockerfile content and returns the content.

    The code idea was has been borrowed from docker-py.
    This function returns a tuple with the Dockerfile file name and it's
    content.

    """
    if not dockerfile:
        return (None, None)

    dockerfile = os.path.join(path, dockerfile)
    try:
        with open(dockerfile, 'r') as df:
            return ('Dockerfile', df.read())
    except IOError as exp:
        sys.exit(exp)

def get_command(cmd_list):
    """Extract command from a docker command line."""
    for word in cmd_list:
        if word.startswith('-'):
            continue
        return word
    return ''


def build_file_list(root):
    """This function has been borrowed from docker-py."""
    files = []
    for dirname, dirnames, fnames in os.walk(root):
        for filename in fnames + dirnames:
            longpath = os.path.join(dirname, filename)
            files.append(
                longpath.replace(root, '', 1).lstrip('/')
            )

    return files


def create_archive(root, files=None, fileobj=None, gzip=False, dockerfile=None):
    """This function has been borrowed from docker-py."""
    if not fileobj:
        fileobj = tempfile.NamedTemporaryFile()
    dockerfile = dockerfile or (None, None)
    t = tarfile.open(mode='w:gz' if gzip else 'w', fileobj=fileobj)
    if files is None:
        files = build_file_list(root)
    for path in files:
        if path == dockerfile[0]:
            continue
        i = t.gettarinfo(os.path.join(root, path), arcname=path)
        if i is None:
            # This happens when we encounter a socket file. We can safely
            # ignore it and proceed.
            continue
        try:
            # We open the file object in binary mode for Windows support.
            with open(os.path.join(root, path), 'rb') as f:
                t.addfile(i, f)
        except IOError:
            # When we encounter a directory the file object is set to None.
            t.addfile(i, None)
        if any(dockerfile):
            info = tarfile.TarInfo(dockerfile[0])
            info.size = len(dockerfile[1])
            t.addfile(info, io.BytesIO(dockerfile[1].encode('utf-8')))

    t.close()
    fileobj.seek(0)
    return fileobj


def get_build_context(cmd):
    for path in cmd[1:]:
        if os.path.isdir(path):
            return path
    sys.exit('build context path not found.')


def get_build_dockerfile():
    for index, arg in enumerate(sys.argv):
        if arg == '-f' or arg == '--file':
            return sys.argv[index + 1]
    return None


def body_generator(data, files, boundary):
    if data:
        for key in data:
            arg = key
            value = data[key]
            yield('--{}\r\n'.format(boundary))
            yield('Content-Disposition: form-data; name="{}"\r\n\r\n'.format(arg))
            yield('{}\r\n'.format(value))
    if files:
        for key in files:
            arg = key
            (filename, fileobj) = files[key]
            fileobj.seek(0)
            yield('--{}\r\n'.format(boundary))
            yield('Content-Disposition: form-data; name="{}"; filename="{}"\r\n'.format(
                   arg, filename))
            yield('Content-Type: application/octet-stream\r\n\r\n')
            while True:
                chunk = fileobj.read(16384)
                if not chunk:
                    yield('\r\n')
                    break
                yield (chunk)
    if data or files:
        yield('--{}--\r\n'.format(boundary))


def handle_remote(cmd):
    files = None

    if cmd == 'build':
        context_path = get_build_context(sys.argv)
        dockerfile = process_dockerfile(get_build_dockerfile(), context_path)
        archive_name = str(uuid4())[:13] + '_context.tar.gz'
        archive = create_archive(
            context_path, dockerfile=dockerfile, gzip=True
        )
        files = {'docker_context': (archive_name, archive)}

    stdin = []
    if cmd == 'exec' and '--interactive' in sys.argv or '-i' in sys.argv:
        try:
            while True:
                stdin.append(raw_input())
        except EOFError:
            pass

    data = {'command': json.dumps(sys.argv), 'stdin': json.dumps(stdin)}
    attempt = 0
    boundary = "98215567712697562581705625561"
    while attempt < 16:
        try:
            response = requests.put(
                'http://localhost:5000/{cmd}'.format(cmd=cmd),
                data=body_generator(data, files, boundary),
                headers={'Content-Type': 'multipart/form-data; boundary={}'.format(boundary)}
            )
        except (requests.ConnectionError, urllib3.exceptions.NewConnectionError):
            pass
        else:
            break
        attempt += 1
        sleep(attempt*2)
    else:
        sys.exit('The Docker service is currently unavailable.')

    if response.status_code != 202:
        sys.exit('This Docker command is currently not available ' \
                 'on the platform ({code})\nRemote traceback:\n{msg}'.format(
                    code=response.status_code,
                    msg = response.json().get('traceback', 'unknown error')))

    task_url = response.headers['Location']

    sleep(0.5)
    TIMEOUT = 3600
    DELAY = 3
    for _ in range(TIMEOUT/DELAY):
        response = requests.get(task_url)
        response.raise_for_status()
        if response.status_code == 200:
            state = response.json()['state']
            if state == 'SUCCESS':
                print(response.json()['output'].rstrip('\n').encode('utf-8'))
                sys.exit(int(response.json()['retcode']))
            elif state == 'FAILURE':
                sys.exit('internal error')
        sleep(DELAY)

    sys.exit('command timeout')


if __name__ == '__main__':
    cmd = get_command(sys.argv[1:])
    handle_remote(cmd)
