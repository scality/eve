#!/usr/bin/env python

from __future__ import print_function
import json
import os
import requests
import sys
import tarfile
import tempfile
from time import sleep
from uuid import uuid4


def get_command(cmd_list):
    """Extract command from a docker command line."""
    for word in cmd_list:
        if word.startswith('-'):
            continue
        return word
    return ''


def build_file_list(root):
    """This function has been borrowed from docker-py."""
    files = []
    for dirname, dirnames, fnames in os.walk(root):
        for filename in fnames + dirnames:
            longpath = os.path.join(dirname, filename)
            files.append(
                longpath.replace(root, '', 1).lstrip('/')
            )

    return files


def create_archive(root, files=None, fileobj=None, gzip=False):
    """This function has been borrowed from docker-py."""
    if not fileobj:
        fileobj = tempfile.NamedTemporaryFile()
    t = tarfile.open(mode='w:gz' if gzip else 'w', fileobj=fileobj)
    if files is None:
        files = build_file_list(root)
    for path in files:
        i = t.gettarinfo(os.path.join(root, path), arcname=path)
        if i is None:
            # This happens when we encounter a socket file. We can safely
            # ignore it and proceed.
            continue
        try:
            # We open the file object in binary mode for Windows support.
            with open(os.path.join(root, path), 'rb') as f:
                t.addfile(i, f)
        except IOError:
            # When we encounter a directory the file object is set to None.
            t.addfile(i, None)
    t.close()
    fileobj.seek(0)
    return fileobj


def get_build_context(cmd):
    build_context = cmd[-1]
    if not os.path.isdir(build_context):
        sys.exit('build context path seem incorrect (%s).' % build_context)
    return build_context


def body_generator(data, files, boundary):
    if data:
        for key in data:
            arg = key
            value = data[key]
            yield('--{}\r\n'.format(boundary))
            yield('Content-Disposition: form-data; name="{}"\r\n\r\n'.format(arg))
            yield('{}\r\n'.format(value))
    if files:
        for key in files:
            arg = key
            (filename, fileobj) = files[key]
            fileobj.seek(0)
            yield('--{}\r\n'.format(boundary))
            yield('Content-Disposition: form-data; name="{}"; filename="{}"\r\n'.format(
                   arg, filename))
            yield('Content-Type: application/octet-stream\r\n\r\n')
            while True:
                chunk = fileobj.read(16384)
                if not chunk:
                    yield('\r\n')
                    break
                yield (chunk)
    if data or files:
        yield('--{}--\r\n'.format(boundary))


def handle_remote(cmd):
    files = None

    if cmd == 'build':
        context_path = get_build_context(sys.argv)
        archive_name = str(uuid4())[:13] + '_context.tar.gz'
        archive = create_archive(root=context_path, gzip=True)
        files = {'docker_context': (archive_name, archive)}

    stdin = []
    if cmd == 'exec' and '--interactive' in sys.argv or '-i' in sys.argv:
        try:
            while True:
                stdin.append(raw_input())
        except EOFError:
            pass

    data = {'command': json.dumps(sys.argv), 'stdin': json.dumps(stdin)}
    attempt = 0
    boundary = "98215567712697562581705625561"
    while attempt < 16:
        try:
            response = requests.put(
                'http://localhost:5000/{cmd}'.format(cmd=cmd),
                data=body_generator(data, files, boundary),
                headers={'Content-Type': 'multipart/form-data; boundary={}'.format(boundary)}
            )
        except requests.ConnectionError:
            pass
        else:
            break
        attempt += 1
        sleep(attempt*2)
    else:
        sys.exit('The Docker service is currently unavailable.')

    if response.status_code != 202:
        sys.exit('This Docker command is currently not available ' \
                 'on the platform ({code})\nRemote traceback:\n{msg}'.format(
                    code=response.status_code,
                    msg = response.json().get('traceback', 'unknown error')))

    task_url = response.headers['Location']

    sleep(0.5)
    TIMEOUT = 3600
    DELAY = 3
    for _ in range(TIMEOUT/DELAY):
        response = requests.get(task_url)
        response.raise_for_status()
        if response.status_code == 200:
            state = response.json()['state']
            if state == 'SUCCESS':
                print(response.json()['output'].rstrip('\n').encode('utf-8'))
                sys.exit(int(response.json()['retcode']))
            elif state == 'FAILURE':
                sys.exit('internal error')
        sleep(DELAY)

    sys.exit('command timeout')


if __name__ == '__main__':
    cmd = get_command(sys.argv[1:])
    handle_remote(cmd)
